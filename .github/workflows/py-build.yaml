name: Python Build
# description: |
#     This workflow builds Python applications.  It installs dependencies, runs linting with ruff, runs tests with pytest, and uploads the build artifact.
#     This workflow is designed to be reusable and can be called from other workflows.
on:
  workflow_call:
    inputs:
      python_version:
        description: "The version of Python to use"
        required: false
        type: string
        default: "3.12"

      working_directory:
        description: "The working directory containing the Python application"
        required: true
        type: string

      ruff_config:
        description: "Path to ruff configuration file relative to working_directory"
        required: false
        type: string
        default: ".ruff.toml"

      pytest_args:
        description: "Additional arguments to pass to pytest"
        required: false
        type: string
        default: ""

      cache_dependencies:
        description: "Whether to cache dependencies"
        required: false
        type: boolean
        default: false

      coverage_source:
        description: "Source directory for coverage reporting (relative to working_directory)"
        required: false
        type: string
        default: "."

      setup_files:
        description: "JSON array of files to include in the artifact (e.g. ['README.md', 'LICENSE'])"
        required: false
        type: string
        default: ""

      artifact_name:
        description: "The name of the artifact to upload"
        required: false
        type: string
        default: "python-build-artifact"

      upload_artifact:
        description: "Whether to upload the build artifact"
        required: false
        type: boolean
        default: true

      unpack_filename:
        description: "The final file to unpack into the artifact"
        required: false
        type: string
        default: ""

      unpack_directory:
        description: "The directory to pull from the unpacked file"
        required: false
        type: string
        default: ""

      version:
        description: "The version of the application"
        required: false
        type: string
        default: "1.0.0"

      create_distribution:
        description: "Whether to create a distribution package"
        required: false
        type: boolean
        default: true

      generate_stubs:
        description: "Whether to generate type stubs"
        required: false
        type: boolean
        default: true

      stubs_output_dir:
        description: "Directory to output generated type stubs (relative to working_directory)"
        required: false
        type: string
        default: "stubs"

      stubs_project_name:
        description: "The project name for which to generate stubs"
        required: false
        type: string
        default: ""

  workflow_dispatch:

jobs:
  build:
    name: Build and test Python app
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install poetry
        run: |
          curl -sSL https://install.python-poetry.org | python3 -
          echo "${HOME}/.local/bin" >> $GITHUB_PATH

      # - name: Cache Poetry dependencies
      #   if: ${{ inputs.cache_dependencies }}
      #   uses: actions/cache@v4
      #   with:
      #     path: |
      #       ~/.cache/pypoetry
      #       ${{ inputs.working_directory }}/.venv
      #     key: ${{ runner.os }}-poetry-${{ hashFiles(format('{0}/poetry.lock', inputs.working_directory)) }}
      #     restore-keys: |
      #       ${{ runner.os }}-poetry-

      - name: Configure poetry
        run: |
          poetry config virtualenvs.in-project true
          # poetry config cache-dir ${HOME}/.cache/pypoetry

      - name: Install dependencies
        working-directory: ${{ inputs.working_directory }}
        run: |
          poetry install --with dev

      - name: Update package version
        if: ${{ inputs.version != '' && inputs.version != '1.0.0' }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          poetry version ${{ inputs.version }}
          echo "Updated package version to ${{ inputs.version }}"

      - name: Ruff format
        working-directory: ${{ inputs.working_directory }}
        run: |
          if [ -f "${{ inputs.ruff_config }}" ]; then
            poetry run ruff format --check --config ${{ inputs.ruff_config }} .
          else
            poetry run ruff format --check .
          fi

      - name: Ruff lint check
        working-directory: ${{ inputs.working_directory }}
        run: |
          if [ -f "${{ inputs.ruff_config }}" ]; then
            poetry run ruff check --config ${{ inputs.ruff_config }} .
          else
            poetry run ruff check .
          fi

      - name: Run tests with coverage
        working-directory: ${{ inputs.working_directory }}
        run: |
          poetry run pytest ${{ inputs.pytest_args }} \
            --cov=${{ inputs.coverage_source }} \
            --cov-report=xml:coverage.xml \
            --cov-report=term \
            --junitxml=pytest-results.xml

      - name: Publish code coverage
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: "${{ inputs.working_directory }}/coverage.xml"
          badge: true
          fail_below_min: false
          format: markdown
          hide_branch_rate: false
          hide_complexity: false
          indicators: true
          output: both
          thresholds: "10 30"

      - name: Add coverage pr comments
        uses: marocchino/sticky-pull-request-comment@v2
        if: github.event_name == 'pull_request'
        with:
          recreate: true
          path: code-coverage-results.md

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ${{ inputs.working_directory }}/pytest-results.xml
          retention-days: 5

      - name: Generate stubs
        if: ${{ inputs.generate_stubs }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          poetry run stubgen -p ${{ inputs.stubs_project_name }} -o ${{ inputs.stubs_output_dir }}

      - name: Build distribution
        if: ${{ inputs.create_distribution }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          poetry build -o tmp_dist
          mkdir -p dist

      - name: Prepare package distribution for artifact
        if: ${{ inputs.create_distribution && inputs.unpack_filename == '' }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          mv tmp_dist/* dist/
          rm -rf tmp_dist

      - name: List artifact contents
        if: ${{ inputs.create_distribution }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          echo "Contents of dist directory:"
          ls -la dist/

      - name: Unpack file for artifact
        if: ${{ inputs.create_distribution && inputs.unpack_filename != '' }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          ls -la -R tmp_dist/

          FILE_TO_UNPACK="tmp_dist/${{ inputs.unpack_filename }}"
          if [ -f "$FILE_TO_UNPACK" ]; then
            echo "Extracting ${FILE_TO_UNPACK} to dist directory..."
            tar -xzf "$FILE_TO_UNPACK" -C dist/

            if [ "${{ inputs.unpack_directory }}" != "" ]; then
              echo "Moving contents from ${{
                inputs.unpack_directory
              }} to dist root..."
              mv "dist/${{ inputs.unpack_directory }}"/* dist/
              rm -rf "dist/${{ inputs.unpack_directory }}"
            fi
            
            echo "Successfully extracted ${FILE_TO_UNPACK} contents to dist/"
          else
            echo "Error: Specified file $FILE_TO_UNPACK does not exist."
            exit 1
          fi
          rm -rf tmp_dist

      - name: Prepare additional files for artifact
        if: ${{ inputs.create_distribution && inputs.setup_files != '' }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          echo "Preparing additional files for artifact..."
          FILES_TO_COPY=$(echo '${{ inputs.setup_files }}' | jq -r '.[]')
          for FILE in $FILES_TO_COPY; do
            if [ -f "$FILE" ]; then
              cp "$FILE" dist/
              echo "Copied $FILE to dist/"
            else
              echo "Warning: $FILE does not exist and will be skipped."
            fi
          done

      - name: List artifact contents
        if: ${{ inputs.create_distribution }}
        working-directory: ${{ inputs.working_directory }}
        run: |
          echo "Contents of dist directory:"
          ls -la dist/

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        if: ${{ inputs.create_distribution && inputs.upload_artifact }}
        with:
          name: ${{ inputs.artifact_name }}
          path: ${{ inputs.working_directory }}/dist/*
          include-hidden-files: false
          if-no-files-found: error